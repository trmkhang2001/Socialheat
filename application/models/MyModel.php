<?php

namespace app\models;

use app\common\utilities\Common;

class MyModel extends \CI_Model {

	/**
	 * @var $db \CI_DB_query_builder
	 */
	public static $db;
	/**
	 * @var $cache \CI_Cache
	 */
	public static $cache;

	public static function tableName()
	{
		return static::tableName();
	}

	public static function getFields()
	{
		return static::tableName();
	}

	public static $requiredFiled;

	public function __construct()
	{
		parent::__construct();
		self::$db = &get_instance()->db;
		self::$cache = &get_instance()->cache;
	}

	public function __get($key)
	{
		return parent::__get($key); // TODO: Change the autogenerated stub
	}
	public static function find($conditionStatus = TRUE, $alias = '')
	{
		/**
		 * @var  $query \CI_DB_query_builder
		 */
		if($alias){
			$query = self::$db->from(self::tableName().' '. $alias);
		}else{
			$query = self::$db->from(self::tableName());
		}
		if($conditionStatus === TRUE){
			if($alias){
				$query->where($alias . '.status <> ' . STATUS_DELETE);
			}else{
				$query->where(self::tableName() . '.status <> ' . STATUS_DELETE);
			}
		}
		return $query;
	}

	public static function findOne($condition)
	{
		return self::findByConditions($condition);
	}

	/**
	 * @param $name
	 * @param $dbObject \CI_DB_query_builder
	 * @param $row
	 * @param int $ttl
	 * @return mixed
	 */
	public static function queryBuilder($name,$dbObject,$row, $ttl = 2592000,$is_object = TRUE,$count_all_results = FALSE, $prefixCache = TRUE){

		if($prefixCache === TRUE){
			$name =static::tableName().'_'.$name;
		}
		$name .= '.cache';
		$res = self::getCache($name);
		/**
		 * @var  $dbObject  \CI_DB_query_builder
		 */
		if($res){
			$dbObject->reset_query();
			return $res;
		}
		if($count_all_results === TRUE){
			$res = $dbObject->count_all_results();
		}else{

			if($is_object === TRUE && $row){
				$res =$dbObject->get()->row();
			}elseif ($is_object === TRUE && !$row){
				$res =  $dbObject->get()->result();
			}elseif ($is_object === FALSE && $row){
				$res =$dbObject->get()->row_array();
			}elseif ($is_object === FALSE && !$row){
				$res =$dbObject->get()->result_array();
			}
		}
		self::setCache($name,$res,$ttl);
		return $res;
	}

	public static function setCache($name, $res, $ttl = 300)
	{
		$path_folder_cache = FCPATH . '/application/cache';
		if ( ! file_exists($path_folder_cache))
		{
			mkdirs($path_folder_cache);
		}
		self::$cache->save($name, $res, $ttl);
	}

	public static function getCache($name)
	{
		$res = self::$cache->get($name);
		return $res;
	}

	public static function findByConditions($conditions = array())
	{
		$query = self::find()->where($conditions);
		return $query;
	}

	public static function getByRange($conditions = array(), $limit = ITEM_PER_PAGE_14, $offset = 0)
	{
		$query = self::find()->where($conditions)->limit($limit, $offset);
		return $query;
	}

	public function findByMultipleId($ids = array())
	{
		$query = self::find()->where_in('id', $ids);
		return $query;
	}


	public static function findKeyValue($fields, $condition = '', $limit = 0, $orderBy = '')
	{
		$rows = self::findWithFields($fields, $condition, $limit, $orderBy);
		return Common::keyValue($rows, $fields);
	}

	public static function findWithFields($fields = array(), $conditions = array(), $limit = 0, $orderBy = '')
	{
		$query = self::find()->select($fields);
		if ($conditions)
		{
			$query->where($conditions);
		}
		if ($limit)
		{
			$query->limit($limit);
		}
		if ($orderBy)
		{
			$query->order_by($orderBy);
		}
		return $query;
	}

	public function save($data = array())
	{

		$field_list = static::get_field_list();
		foreach ($data as $index => $value)
		{
			if ( ! in_array($index, $field_list, FALSE))
			{
				unset($data[$index]);
			}
			if ($index === 'status' && empty($data[$index]))
			{
				$data['status'] = STATUS_ACTIVE;
			}
			if ($index === 'created_date' && empty($data[$index]))
			{
				$data['created_date'] = date('Y-m-d H:i:s');
			}
		}
		self::$db->insert(static::tableName(), $data);
		$error = self::$db->error();

		if ($error['code'])
		{
			static::handle_error_code($error);
		}
		self::clearCache(static::tableName());

		$dbObj = self::$db;
		/**
		 * @var  $dbObj \CI_DB_odbc_driver
		 */
		$id = $dbObj->insert_id();
		return $id;

	}

	public static function handle_error_code($error)
	{
//		$code = $error['code'];
		throw new \Exception($error['message']);
	}

	public function update($id, $data,$isReturnError = FALSE,$is_check_field = TRUE)
	{
		if($is_check_field){
			$field_list = static::get_field_list();
			foreach ($data as $index => $value)
			{
				if ( ! in_array($index, $field_list, FALSE))
				{
					unset($data[$index]);
				}
				if ($index === 'updated_date' && empty($data[$index]))
				{
					$data['updated_date'] = date('Y-m-d H:i:s');
				}
			}
		}
		self::$db->update(static::tableName(), $data, array('id' => (int)$id));
		$error = self::$db->error();
		if($isReturnError === TRUE){
			return  $error;
		}
		if ($error['code'])
		{
			static::handle_error_code($error);
		}
		self::clearCache(static::tableName());
		return TRUE;
	}

	public function delete($id, $data)
	{
		if (SYSTEM_DELETE)
		{
			self::$db->delete(static::tableName(), array('id' => (int)$id));
		} else
		{
			$data['deleted_date'] = date('Y-m-d H:i:s');
			$data['status'] = STATUS_DELETE;
			$this->update($id, $data);
		}
		self::clearCache(static::tableName());
		return TRUE;

	}

	public static function insertBatch($data)
	{
		self::$db->insert_batch(static::tableName(), $data);
		self::clearCache();
		return TRUE;

	}

	public static function deleteByByMultipleKey($ids = array(), $key = 'id')
	{
		self::$db->from(static::tableName())->where_in($key, $ids)->delete();
		self::clearCache(static::tableName());
	}

	public static function deleteBatch($conditions = array())
	{

		self::$db->where($conditions);
		self::$db->delete(static::tableName());
		self::clearCache();
		return TRUE;
	}

	public static function updateBatch($datas = array(), $condition = NULL)
	{
		self::$db->update_batch(static::tableName(), $datas, $condition);
		$error = self::$db->error();
		if ($error['code'])
		{
			static::handle_error_code($error);
		}
		self::clearCache();
		return TRUE;
	}

	public static function clearCache($name = '')
	{
		if (is_file($name))
		{
			@unlink($name);
		} else
		{
			$path = APPPATH . 'cache/' . static::tableName() . '*.cache';
			$files = glob($path);
			foreach ($files as $file)
			{
				@unlink($file);
			}
		}

	}


	/**
	 * return array of fields
	 *
	 * @return array|null
	 */
	public static function get_field_list()
	{
		if (static::$fields !== NULL)
		{
			return static::$fields;
		}

		$fields = static::$db->list_fields(static::tableName());
		return $fields;
	}

	public static function validateForm($data, $requiredFiled = array())
	{
		$formValidation = new \CI_Form_validation();
		$formValidation->set_data($data);
		if (empty($requiredFiled))
		{
			$requiredFiled = static::$requiredFiled;
		}
		foreach ($requiredFiled as $key => $require)
		{
			if ($key === 'email')
			{
				$formValidation->set_rules('email', 'Email', 'required|valid_email');
			} else
			{
				$formValidation->set_rules($key, $require, 'required');
			}
		}
		$formValidation->set_message('greater_than', '{field} phải lớn hơn {param}.');
		$formValidation->set_message('required', 'Chưa nhập %s');
		$formValidation->set_message('valid_email', 'Địa chỉ %s không hợp lệ');

		$formValidation->run();
		$errorArray = $formValidation->error_array();
		$result['validation'] = $errorArray;
		return $result;
	}

	public static function findByEmail($email)
	{
		if ( ! filter_var($email, FILTER_VALIDATE_EMAIL))
		{
			return NULL;
		}
		$query = static::findByConditions(array('email' => $email));
		return $query;
	}

	public function getByIdAsArray($id)
	{
		$obj = $this->findOne($id);
		$data = array();
		if ($obj)
		{
			$data = $obj->get()->result_array();
		}
		return $data;
	}

	public function getRange($conditions = array(), $offset = 0, $itemPerPage = 0, $orderBy = '')
	{
		$dbObject = $this->find();
		if ($itemPerPage)
		{
			$dbObject->limit($itemPerPage);
		}
		if ($orderBy)
		{
			$dbObject->order_by($orderBy);
		}
		if ($conditions !== NULL)
		{
			$dbObject->where($conditions);
		}
		$dbObject->offset($offset);
		return $dbObject;
	}

	public function findByWithFieldsCache($fields = array(), $conditions = array(), $row = FALSE)
	{
		$name = 'findByWithFieldsCache_' . http_build_query($fields) . http_build_query($conditions) . $row;
		$dbObj = self::findWithFields($fields, $conditions);
		$res = self::queryBuilder($name, $dbObj, $row);
		return $res;

	}

	public function findByConditionsCache($conditions = array(), $row = FALSE)
	{
		$name = 'findByConditionsCache_' . http_build_query($conditions) . $row;
		$dbObj = self::findByConditions($conditions);
		$res = self::queryBuilder($name, $dbObj, $row);
		return $res;

	}

	public function load($data)
	{
		$fields = self::getFields();
		$res = array();
		foreach ($fields as $field)
		{
			if ( ! empty($data[$field]))
			{
				$res[$field] = $data[$field];
			}
		}
		return $res;
	}

	/**
	 * @param $conditions
	 * @param $dbObj
	 */
	public function getConditions($conditions, $dbObj)
	{
		if ($conditions !== NULL)
		{
			if (isset($conditions[0]) && is_array($conditions[0]))
			{
				foreach ($conditions as $condition)
				{

					if (isset($condition[0]) && is_array($condition))
					{
						$dbObj->group_start();

						foreach ($condition as $c)
						{
							$dbObj->or_where($c);
						}
						$dbObj->group_end();

					} else
					{

						$dbObj->where($condition);

					}

				}
			} else
			{
				$dbObj->where($conditions);
			}
		}
		return $dbObj;
	}
}